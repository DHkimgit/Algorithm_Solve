# 알고리즘
    2003 - 투포인터 알고리즘
    1644 - 에라토스테네스의 체 & 투포인터 알고리즘


## 에라토스테네스의 채

* 다수의 자연수에 대하여 소수 여부를 판단할때 사용하는 대표적인 알고리즘
	* 일반적인 소수판별 알고리즘의 경우
    for i in range(2, N+1):
    for j in range(2, i):
        if i % j == 0:
            break
    else:
        arr.append(i)
    와 같은 이중 반복문 통해 소수를 판별 => 시간 복잡도 O(N^2) 로 복잡
    
    * 에라토스테네스의 채 알고리즘의 경우
        1. 2부터 N까지의 모든 자연수를 나열한다
        2. 남은 수 중에서 아직 처리하지 않은 가장 작은 자연수 i를 찾는다.
        3. 남은 수 중에서 i의 배수를 모두 제거한다.
        4. 더 이상 반복할 수 없을 때까지 2와 3의 과정을 반복한다.
    
    * 코드 예시
        arr = [True for i in range(N + 1)] # 처음엔 모든 수가 소수(TRUE)인것으로 초기화

        for i in range(2, int(math.sqrt(N)) + 1): #에라토스테네스 알고리즘 수행. 2부터 n의 제곱근까지 
            if arr[i] == True: # 만약 배열 안의 수가 소수라면
                j = 2 # 배수를 제거하는데 사용하는 변수
                while i*j <= N: # 배수가 N에 도달할때까지 j값을 증가
                    arr[i * j] = False # 배수에 해당하는 수는 소수에서 제외
                    j += 1
    
        for i in range(2, N+1): # 주어진 범위 안에서 소수(True)인 i값만 새로운 배열 pl에 할당
            if arr[i]:
                pl.append(i)    
    
## 투포인터  
* 배열이나 문자열같은 선형 구조에서 각자 다른 원소를 가리키는 2개의 포인터를 조작해가면서 원하는 것을 얻어내는 알고리즘
* 리스트에 순차적으로 접근해야 할때 두개의 점의 위치를 기록하면서 처리하는 알고리즘
    
    * 투포인터 알고리즘의 구체적 원리
        1. 시작점(start) 과 끝점(end) 가 첫번째 원소의 인덱스(0) 을 가르키게 한다.
        2. 현재 부분합이 M과 같다면, 카운트 한다.
        3. 현재 부분합이 M보다 작다면 end를 1 증가시킨다.
        4. 현재 부분합이 M보다 크거나 같다면 start를 1 증가시킨다.
        5. 모든 경우를 확인할 때 까지 2에서 4를 반복한다.
    
    * 코드 예시
        for start in range(N): 
            while interval_sum < M and end < N:
                interval_sum = interval_sum + arr[end]
                end = end + 1
            if interval_sum == M:
                count += 1
            interval_sum = interval_sum - arr[start]
            
        배열의 크기가 N인 수열에서 부분합이 M보다 커지거나 끝점이 배열의 마지막 인덱스에 다다를 때 까지 끝점을 하나씩 증가
        시키면서 부분합을 더한다. 이 과정이 종료되었을때 부분합이 목표하는 M와 같으면 카운터 변수를 더하고
        부분합이 목표치보다 커졌을 경우 시작점을 한칸 증가 시키고 이전 시작점 인덱스의 배열값을 부분합에서 빼준다.