n = int(input())
arr = list(map(int, input().split()))


int_sum = 0
sl = 0
dp = [0]*n # 계산 과정에서 최댓값을 저장하는 배열
dp[0] = arr[0] # 배열의 가장 처음은 입력되는 배열의 처음과 같아야 한다. dp[0]이 0으로 초기화 되있을 경우 입력된 배열이 음수로만
               # 이루어져 있을때 문제가 발생했다. (n = 5 이고 배열이 -1 -2 -3 -4 -5일때 -1이 아닌 0이 출력됨)

for i in range(1, n):
    dp[i] = max(arr[i], dp[i-1] + arr[i])
    sl = max(dp[i], sl)

print(max(dp))

""" 연속합
n개의 정수로 이루어진 임의의 수열에서 연속된 수를 합하여 구할 수 있는 값 중 가장 큰 값을 출력

문제 풀이의 핵심은
'n번까지의 연속합의 최대값은 [n-1번까지의 최대값 + n번 값] or [n번 값] 둘 중 큰 값이다.'
(출처 : https://rightbellboy.tistory.com/83)

큰 값을 배열 dp[] 에 저장하면서 다음 값을 더해나가며 비교하면 된다.
이 문제는 브루트 포스, 선형적인 방법으로 풀 수도 있는데 그럴 경우 시간 복잡도가 O(n^2) 이 되어버린다.
반면에 동적 계획법으로 문제를 접근할 경우 O(2n) 의 낮은 복잡도로 문제를 풀 수 있다.
"""